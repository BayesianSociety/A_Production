<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>WordChomp — Pac-Man Letters (Local)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    /* Retro layout */
    html, body { height: 100%; }
    body {
      margin: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      background: #333;
      color: #0f0;
      font-family: "Courier New", Courier, monospace;
      user-select: none;
    }
    #game { text-align: center; }
    /* 28x31 tiles @ 16px => 448x496 canvas */
    canvas {
      width: 448px; height: 496px;
      border: 2px solid #000;
      background: #000;
      image-rendering: pixelated;
      image-rendering: crisp-edges;
      display: block;
      margin: 8px auto;
    }
    #hud {
      display: flex;
      gap: 24px;
      justify-content: center;
      align-items: center;
      font-size: 18px;
      line-height: 1.2;
    }
    #wordBlanks { letter-spacing: 6px; }
    #msg { margin-top: 6px; min-height: 20px; color: #9f9; }
    .btn { color:#0f0; background:#111; border:1px solid #0f0; padding:4px 8px; cursor:pointer; }

    /* HUD pills & warnings */
    .pill { padding: 2px 8px; border:1px solid #0f0; border-radius: 10px; }
    .badge { display:inline-block; min-width:20px; text-align:center; border:1px solid #0f0; border-radius: 4px; padding: 0 6px; }
    #time.lowTime { color:#f66; border-color:#f66; }
    #wordBlanks span { display:inline-block; min-width: 14px; }
    #wordBlanks .done { color:#0f0; }
    #wordBlanks .todo { color:#090; }
    #next strong { font-size: 18px; }
  </style>
</head>
<body>
<div id="game">
  <div id="hud">
    <div id="score">Score: 0</div>
    <div id="lives">Lives: 3</div>
    <div id="time">Time: 00:00</div>
    <div id="next" title="Next required letter">Next: <span class="badge">?</span></div>
  </div>
  <canvas id="c" width="448" height="496"></canvas>
  <div id="wordBlanks">_ _ _</div>
  <div id="msg">Arrow keys to move • P pause • H hint</div>
  <div>
    <button class="btn" id="toggleHint">Toggle Hint</button>
  </div>
</div>

<script>
'use strict';
/*
ASSUMPTIONS (explicit, per spec):
- EXACT 28x31 map below is authoritative. Tile values: 1=wall, 0=empty corridor, 2=pellet corridor (visual).
- Grid/tile contract: movement lanes are tile centers at (N + 0.5). Collision lookups use Math.floor(tileCoords).
- Letters must spawn and move ONLY on pellet tiles (value 2) and are always edible.
- The player must eat letters in the exact order of the active word; wrong-order contact only deducts score.
- Facing semantics: player.lastFacing is an angle in radians where 0=right, +π/2=down, π=left, −π/2=up.
  Rendering draws a wedge that inherently faces RIGHT; we rotate by lastFacing (no magic offsets).
- “HARDEN” scope = add guards against edge cases (invalid map values, stuck letters, numeric drift) without changing gameplay.
- Single file, no external libraries, must run via file:// in a modern browser.
*/

const CONFIG = {
  words: ["DOG","CAT","SCHOOL","CAR","TREE","HOUSE"],
  roundTimeMs: 90_000,
  letterSpeedTilesPerSec: 6,
  playerSpeedTilesPerSec: 9,
  lives: 3,
  penalties: { wrongLetter: 50 },
  rewards: { perCorrectLetter: 100, wordBonus: 500 },
  showHint: false,
  showWord: false,
  audio: { enabled: false },
  tileSize: 16,
  cols: 28,
  rows: 31,
  colors: { wall:"#00f", dot:"#fff", pac:"#ff0", text:"#0f0", bg:"#000", stroke:"#111" },
};

/* -------- Map (EXACTLY as provided) -------- */
const MAP = [
  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
  [1,2,2,2,2,2,2,2,2,2,2,2,2,1,1,2,2,2,2,2,2,2,2,2,2,2,2,1],
  [1,2,1,1,1,1,2,1,1,1,1,1,2,1,1,2,1,1,1,1,1,2,1,1,1,1,2,1],
  [1,2,1,0,0,1,2,1,0,0,0,1,2,1,1,2,1,0,0,0,1,2,1,0,0,1,2,1],
  [1,2,1,0,0,1,2,1,0,0,0,1,2,1,1,2,1,0,0,0,1,2,1,0,0,1,2,1],
  [1,2,1,1,1,1,2,1,1,1,1,1,2,1,1,2,1,1,1,1,1,2,1,1,1,1,2,1],
  [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1],
  [1,2,1,1,1,1,2,1,1,2,1,1,1,1,1,1,1,1,2,1,1,2,1,1,1,1,2,1],
  [1,2,1,1,1,1,2,1,1,2,1,1,1,1,1,1,1,1,2,1,1,2,1,1,1,1,2,1],
  [1,2,2,2,2,2,2,1,1,2,2,2,2,1,1,2,2,2,2,1,1,2,2,2,2,2,2,1],
  [1,1,1,1,1,1,2,1,1,1,1,1,0,1,1,0,1,1,1,1,1,2,1,1,1,1,1,1],
  [0,0,0,0,0,1,2,1,1,1,1,1,0,1,1,0,1,1,1,1,1,2,1,0,0,0,0,0],
  [0,0,0,0,0,1,2,1,1,0,0,0,0,0,0,0,0,0,0,1,1,2,1,0,0,0,0,0],
  [0,0,0,0,0,1,2,1,1,0,1,1,1,0,0,1,1,1,0,1,1,2,1,0,0,0,0,0],
  [1,1,1,1,1,1,2,1,1,0,1,0,0,0,0,0,0,1,0,1,1,2,1,1,1,1,1,1],
  [0,0,0,0,0,0,2,0,0,0,1,0,0,0,0,0,0,1,0,0,0,2,0,0,0,0,0,0],
  [1,1,1,1,1,1,2,1,1,0,1,0,0,0,0,0,0,1,0,1,1,2,1,1,1,1,1,1],
  [0,0,0,0,0,1,2,1,1,0,1,1,1,1,1,1,1,1,0,1,1,2,1,0,0,0,0,0],
  [0,0,0,0,0,1,2,1,1,0,0,0,0,0,0,0,0,0,0,1,1,2,1,0,0,0,0,0],
  [0,0,0,0,0,1,2,1,1,1,1,1,0,1,1,0,1,1,1,1,1,2,1,0,0,0,0,0],
  [1,1,1,1,1,1,2,1,1,1,1,1,0,1,1,0,1,1,1,1,1,2,1,1,1,1,1,1],
  [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1],
  [1,2,1,1,1,1,2,1,1,1,1,1,2,1,1,2,1,1,1,1,1,2,1,1,1,1,2,1],
  [1,2,1,1,1,1,2,1,1,1,1,1,2,1,1,2,1,1,1,1,1,2,1,1,1,1,2,1],
  [1,2,2,2,1,1,2,2,2,2,2,2,2,0,0,2,2,2,2,2,2,2,1,1,2,2,2,1],
  [1,1,1,2,1,1,2,1,1,2,1,1,1,1,1,1,1,1,2,1,1,2,1,1,2,1,1,1],
  [1,1,1,2,1,1,2,1,1,2,1,1,1,1,1,1,1,1,2,1,1,2,1,1,2,1,1,1],
  [1,2,2,2,2,2,2,1,1,2,2,2,2,1,1,2,2,2,2,1,1,2,2,2,2,2,2,1],
  [1,2,1,1,1,1,1,1,1,1,1,1,2,1,1,2,1,1,1,1,1,1,1,1,1,1,2,1],
  [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1],
  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
];

/* -------- Canvas & HUD -------- */
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
const scoreEl = document.getElementById('score');
const livesEl = document.getElementById('lives');
const timeEl = document.getElementById('time');
const blanksEl = document.getElementById('wordBlanks');
const nextEl = document.getElementById('next');
const msgEl = document.getElementById('msg');
document.getElementById('toggleHint').onclick = () => {
  CONFIG.showHint = !CONFIG.showHint;
  updateHUD();
};

/* -------- Utilities -------- */
const rnd = (() => { // deterministic LCG per round
  let s = 1234567;
  return {
    seed(v) { s = (v>>>0) || 1; },
    next() { s = (1103515245 * s + 12345) >>> 0; return s; },
    float() { return (rnd.next() % 10000) / 10000; },
    pick(arr) { return arr[(rnd.next() % arr.length)]; }
  };
})();

function tileCenter(v) { return Math.abs((v - Math.floor(v)) - 0.5) < 0.05; }
function dist2(ax,ay,bx,by) { const dx=ax-bx, dy=ay-by; return dx*dx+dy*dy; }
function fmtMMSS(totalSeconds){
  totalSeconds = Math.max(0, Math.floor(totalSeconds));
  const m = String(Math.floor(totalSeconds/60)).padStart(2,'0');
  const s = String(totalSeconds%60).padStart(2,'0');
  return `${m}:${s}`;
}
function renderBlanks(word, progress){
  const out = [];
  for(let i=0;i<word.length;i++){
    const ch = i < progress ? word[i] : '_';
    const cls = i < progress ? 'done' : 'todo';
    out.push(`<span class="${cls}">${ch}</span>`);
  }
  return out.join(' ');
}

/* -------- Map helpers (hardened) -------- */
function validateMap() {
  // Harden: verify size and values (does not change gameplay; fails loudly if broken).
  if (MAP.length !== CONFIG.rows) throw new Error("Map row count mismatch.");
  for (let y=0; y<CONFIG.rows; y++) {
    if (!Array.isArray(MAP[y]) || MAP[y].length !== CONFIG.cols) {
      throw new Error("Map column count mismatch at row " + y);
    }
    for (let x=0; x<CONFIG.cols; x++) {
      const t = MAP[y][x];
      if (t!==0 && t!==1 && t!==2) throw new Error("Invalid tile value at ("+x+","+y+")");
    }
  }
}
function isPassable(cx, cy) {
  if (cx < 0 || cx >= CONFIG.cols || cy < 0 || cy >= CONFIG.rows) return false;
  const t = MAP[cy][cx];
  return t === 0 || t === 2;
}
function isPellet(cx, cy) {
  if (cx < 0 || cx >= CONFIG.cols || cy < 0 || cy >= CONFIG.rows) return false;
  return MAP[cy][cx] === 2;
}
function canGo(x,y,dx,dy) {
  const cx = Math.floor(x);
  const cy = Math.floor(y);
  return isPassable(cx + dx, cy + dy);
}
function canGoPellet(x,y,dx,dy) {
  const cx = Math.floor(x);
  const cy = Math.floor(y);
  return isPellet(cx + dx, cy + dy);
}
function nearestPelletCenter(x, y, maxR=12) {
  // Harden: fallback to a reachable-looking pellet center near (x,y).
  const sx = Math.floor(x), sy = Math.floor(y);
  if (isPellet(sx, sy)) return [sx+0.5, sy+0.5];
  for (let r=1; r<=maxR; r++) {
    for (let dx=-r; dx<=r; dx++) {
      for (let dy=-r; dy<=r; dy++) {
        const tx = sx+dx, ty = sy+dy;
        if (isPellet(tx, ty)) return [tx+0.5, ty+0.5];
      }
    }
  }
  // Fallback: first pellet in map
  for (let yy=0; yy<CONFIG.rows; yy++) for (let xx=0; xx<CONFIG.cols; xx++) {
    if (isPellet(xx, yy)) return [xx+0.5, yy+0.5];
  }
  return [x, y]; // should not happen on this map
}

/* -------- Grid helpers -------- */
function atCenter(x,y) { return tileCenter(x) && tileCenter(y); }
function alignToGrid(entity) {
  // Harden: eliminate perpendicular drift by snapping near centers.
  const eps = 0.15;
  const centerY = Math.floor(entity.y) + 0.5;
  const centerX = Math.floor(entity.x) + 0.5;
  if (Math.abs(entity.dx) > 0 && Math.abs(entity.y - centerY) < eps) entity.y = centerY;
  if (Math.abs(entity.dy) > 0 && Math.abs(entity.x - centerX) < eps) entity.x = centerX;
}

/* -------- Entities -------- */
const gameState = {
  running: true,
  paused: false,
  lives: CONFIG.lives,
  score: 0,
  roundWord: "DOG",
  progressIndex: 0,
  timeLeftMs: CONFIG.roundTimeMs,
  letters: [],
};

const player = {
  // Central-ish default; spawn search ensures passable start even if this tile changes later.
  spawnX: 14.5, spawnY: 23.5,
  x: 14.5, y: 23.5, dx: 0, dy: 0, wantDx: 1, wantDy: 0,
  speed: CONFIG.playerSpeedTilesPerSec, anim: 0, lastFacing: 0
};

function isTilePassableCenter(tx, ty) { return isPassable(Math.floor(tx), Math.floor(ty)); }

function spawnPlayer() {
  // Harden: find nearest passable tile center to the configured spawn.
  let sx = player.spawnX, sy = player.spawnY;
  if (!isTilePassableCenter(sx, sy)) {
    let found = false;
    for (let r=1; r<=8 && !found; r++) {
      for (let dx=-r; dx<=r && !found; dx++) {
        for (let dy=-r; dy<=r; dy++) {
          const tx = sx+dx, ty = sy+dy;
          if (isTilePassableCenter(tx, ty)) { sx = tx; sy = ty; found = true; break; }
        }
      }
    }
  }
  player.x = sx; player.y = sy;
  player.dx = 0; player.dy = 0;
  player.wantDx = 1; player.wantDy = 0;
}

/* -------- Round & HUD -------- */
function spawnRound(word) {
  // Harden: enforce uppercase letters (visual and matching) without changing config intent.
  word = String(word).toUpperCase();
  gameState.roundWord = word;
  gameState.progressIndex = 0;
  gameState.timeLeftMs = CONFIG.roundTimeMs;
  gameState.letters.length = 0;

  spawnPlayer();

  // Deterministic RNG seed from word
  let seed = 0;
  for (let i=0;i<word.length;i++) seed = (seed*131 + word.charCodeAt(i))>>>0;
  rnd.seed(seed);

  // Candidate spawns = pellet tiles only, away from player & other letters
  const candidates = [];
  for (let y=0;y<CONFIG.rows;y++) for (let x=0;x<CONFIG.cols;x++) {
    if (isPellet(x,y)) {
      const d = dist2(x+0.5,y+0.5, player.x, player.y);
      if (d > 9) candidates.push([x+0.5,y+0.5]);
    }
  }

  const placed = [];
  for (let i=0;i<word.length;i++) {
    let chosen = null;
    let tries = 0;
    while (tries++ < 40 && candidates.length) {
      const idx = rnd.next() % candidates.length;
      const p = candidates[idx];
      const okPlayer = dist2(p[0],p[1], player.x, player.y) >= 4.0; // >= 2 tiles
      const okOthers = placed.every(q => dist2(p[0],p[1], q[0], q[1]) >= 4.0);
      if (okPlayer && okOthers) { chosen = candidates.splice(idx,1)[0]; break; }
      else { candidates.splice(idx,1); } // discard too-close candidate
    }
    if (!chosen) { chosen = nearestPelletCenter(14.5, 11.5); } // guaranteed pellet fallback
    placed.push(chosen);
    gameState.letters.push({
      glyph: word[i], order: i,
      x: chosen[0], y: chosen[1],
      dx: 0, dy: 0,
      speed: CONFIG.letterSpeedTilesPerSec,
      state: "moving",
      stuckTicks: 0 // Harden: track if a letter stops moving inadvertently
    });
  }

  for (const L of gameState.letters) chooseLetterDir(L, true);
  msgEl.textContent = 'New word!';
  updateHUD();
}

function updateHUD() {
  scoreEl.textContent = `Score: ${gameState.score}`;
  livesEl.textContent = `Lives: ${gameState.lives}`;
  const secs = Math.max(0, Math.floor(gameState.timeLeftMs/1000));
  timeEl.textContent = `Time: ${fmtMMSS(secs)}`;
  if (secs <= 10) timeEl.classList.add('lowTime'); else timeEl.classList.remove('lowTime');
  blanksEl.innerHTML = renderBlanks(gameState.roundWord, gameState.progressIndex);
  const nextSpan = document.querySelector('#next .badge');
  const nextCh = gameState.roundWord[gameState.progressIndex] || '?';
  nextSpan.textContent = CONFIG.showHint ? nextCh : '?';
  const btn = document.getElementById('toggleHint');
  btn.textContent = `Hint: ${CONFIG.showHint ? 'ON' : 'OFF'}`;
}

/* -------- Input -------- */
window.addEventListener('keydown', (e)=>{
  if (e.key === 'ArrowUp') { player.wantDx=0; player.wantDy=-1; }
  else if (e.key === 'ArrowDown') { player.wantDx=0; player.wantDy=1; }
  else if (e.key === 'ArrowLeft') { player.wantDx=-1; player.wantDy=0; }
  else if (e.key === 'ArrowRight') { player.wantDx=1; player.wantDy=0; }
  else if (e.key.toLowerCase() === 'p') { gameState.paused = !gameState.paused; msgEl.textContent = gameState.paused ? 'PAUSED' : ''; }
  else if (e.key.toLowerCase() === 'h') { CONFIG.showHint = !CONFIG.showHint; updateHUD(); }
});

/* -------- Movement & Collisions -------- */
function wrapX(x) {
  // Horizontal wrap through tunnels; vertical wrap is not present in this maze.
  if (x < -0.5) return CONFIG.cols-0.5;
  if (x > CONFIG.cols-0.5) return 0.5;
  return x;
}

function chooseLetterDir(L, force=false) {
  // Randomly choose a legal direction on the pellet graph, avoiding instant reversals unless stuck.
  if (!force && !atCenter(L.x, L.y)) return;
  const cx = Math.floor(L.x), cy = Math.floor(L.y);
  const dirs = [];
  const options = [[1,0],[-1,0],[0,1],[0,-1]];
  for (const [dx,dy] of options) {
    const nx = cx + dx, ny = cy + dy;
    if (isPellet(nx,ny)) {
      if (!(dx === -L.dx && dy === -L.dy)) dirs.push([dx,dy]);
    }
  }
  // Harden: if no perpendicular/forward option, allow reverse or any pellet neighbor.
  if (dirs.length === 0) {
    for (const [dx,dy] of options) if (isPellet(cx+dx, cy+dy)) { dirs.push([dx,dy]); }
  }
  if (dirs.length === 0) { L.dx = 0; L.dy = 0; return; } // isolated pellet — stay put
  const pick = rnd.pick(dirs);
  L.dx = pick[0]; L.dy = pick[1];
}

function perpendicularDirs(dx, dy) {
  if (dx !== 0) return [[0,1],[0,-1]];
  if (dy !== 0) return [[1,0],[-1,0]];
  return [[1,0],[-1,0]];
}

function stepLetters(dt) {
  for (const L of gameState.letters) {
    if (L.state !== 'moving') continue;

    const prevX = L.x, prevY = L.y;

    // Keep lane alignment
    alignToGrid(L);

    // Turn at intersections or when blocked on pellet graph
    if (atCenter(L.x, L.y) && !canGoPellet(L.x, L.y, L.dx, L.dy)) {
      chooseLetterDir(L, true);
    }

    // Advance
    const spd = L.speed * dt;
    L.x += L.dx * spd;
    L.y += L.dy * spd;

    // Tunnel wrap
    L.x = wrapX(L.x);

    // If overshot into a non-pellet, snap back & pick new dir
    if (!canGoPellet(L.x, L.y, L.dx, L.dy) && !atCenter(L.x, L.y)) {
      if (L.dx !== 0) L.x = Math.floor(L.x) + 0.5;
      if (L.dy !== 0) L.y = Math.floor(L.y) + 0.5;
      L.dx = L.dy = 0;
      chooseLetterDir(L, true);
    }

    // Occasionally re-choose direction at centers
    if (atCenter(L.x, L.y) && (rnd.next() % 4 === 0)) {
      chooseLetterDir(L, false);
    }

    // Harden: detect being effectively stationary on a corridor and nudge
    const moved2 = dist2(prevX, prevY, L.x, L.y);
    if (moved2 < 1e-6) {
      L.stuckTicks = (L.stuckTicks|0) + 1;
      if (L.stuckTicks > 10 && atCenter(L.x, L.y)) { // try to shake loose
        chooseLetterDir(L, true);
        L.stuckTicks = 0;
      }
    } else {
      L.stuckTicks = 0;
    }
  }

  // Simple separation to avoid overlaps
  for (let i=0;i<gameState.letters.length;i++) {
    const A = gameState.letters[i];
    if (A.state !== 'moving') continue;
    for (let j=i+1;j<gameState.letters.length;j++) {
      const B = gameState.letters[j];
      if (B.state !== 'moving') continue;
      if (dist2(A.x,A.y,B.x,B.y) < 0.16) {
        const dirsA = perpendicularDirs(A.dx, A.dy).filter(([dx,dy]) => canGoPellet(A.x, A.y, dx, dy));
        const dirsB = perpendicularDirs(B.dx, B.dy).filter(([dx,dy]) => canGoPellet(B.x, B.y, dx, dy));
        if (dirsA.length) { const pa = rnd.pick(dirsA); A.dx = pa[0]; A.dy = pa[1]; }
        if (dirsB.length) { const pb = rnd.pick(dirsB); B.dx = pb[0]; B.dy = pb[1]; }
      }
    }
  }
}

function handleCollisions() {
  const need = gameState.roundWord[gameState.progressIndex];
  for (const L of gameState.letters) {
    if (L.state !== 'moving') continue;
    if (dist2(player.x, player.y, L.x, L.y) < 0.25) {
      if (L.glyph === need) {
        L.state = 'collected';
        gameState.progressIndex++;
        gameState.score += CONFIG.rewards.perCorrectLetter;
        msgEl.textContent = `Good! Collected '${L.glyph}'`;
        if (gameState.progressIndex >= gameState.roundWord.length) {
          gameState.score += CONFIG.rewards.wordBonus;
          msgEl.textContent = `Word complete: ${gameState.roundWord}! +${CONFIG.rewards.wordBonus}`;
          const nextWord = CONFIG.words[(CONFIG.words.indexOf(gameState.roundWord)+1) % CONFIG.words.length];
          spawnRound(nextWord);
        }
        updateHUD();
      } else {
        // Wrong order: score penalty, letter persists (per spec)
        gameState.score = Math.max(0, gameState.score - CONFIG.penalties.wrongLetter);
        msgEl.textContent = `Wrong order! Need '${need}'`;
        updateHUD();
      }
    }
  }
}

function stepPlayer(dt) {
  // Keep aligned to lanes to avoid drift across walls
  alignToGrid(player);

  // Buffered turns at centers
  if (atCenter(player.x, player.y) && canGo(player.x, player.y, player.wantDx, player.wantDy)) {
    player.dx = player.wantDx; player.dy = player.wantDy;
  }

  // Stop if blocked right at center
  if (!canGo(player.x, player.y, player.dx, player.dy) && atCenter(player.x, player.y)) {
    player.dx = player.dy = 0;
  }

  // Face in current heading (0=right, +π/2=down, etc.)
  if (player.dx !== 0 || player.dy !== 0) {
    player.lastFacing = Math.atan2(player.dy, player.dx);
  }

  // Advance
  const spd = player.speed * dt;
  player.x += player.dx * spd;
  player.y += player.dy * spd;

  // Horizontal wrap through tunnels
  player.x = wrapX(player.x);

  // Snap back if we nudged into a wall
  if (!canGo(player.x, player.y, player.dx, player.dy) && !atCenter(player.x, player.y)) {
    if (player.dx !== 0) player.x = Math.floor(player.x) + 0.5;
    if (player.dy !== 0) player.y = Math.floor(player.y) + 0.5;
    player.dx = player.dy = 0;
  }

  // Animate mouth; faster when moving
  const speedFactor = (Math.abs(player.dx) + Math.abs(player.dy)) > 0 ? 1 : 0.5;
  player.anim += dt * 10 * speedFactor;
}

/* -------- Rendering -------- */
function drawMaze() {
  const ts = CONFIG.tileSize;
  ctx.fillStyle = CONFIG.colors.bg;
  ctx.fillRect(0,0,canvas.width,canvas.height);

  // Pellets (visual only)
  ctx.fillStyle = CONFIG.colors.dot;
  for (let y=0; y<CONFIG.rows; y++) {
    for (let x=0; x<CONFIG.cols; x++) {
      if (MAP[y][x] === 2) {
        ctx.beginPath();
        ctx.arc(x*ts+ts/2, y*ts+ts/2, 2, 0, Math.PI*2);
        ctx.fill();
      }
    }
  }

  // Walls
  ctx.fillStyle = CONFIG.colors.wall;
  for (let y=0; y<CONFIG.rows; y++) {
    for (let x=0; x<CONFIG.cols; x++) {
      if (MAP[y][x] === 1) {
        ctx.fillRect(x*ts, y*ts, ts, ts);
      }
    }
  }
}

function drawPlayer() {
  const ts = CONFIG.tileSize;
  const px = player.x * ts, py = player.y * ts;

  // Mouth aperture (0 .. ~0.5π)
  const mouth = (Math.sin(player.anim) * 0.25 + 0.25) * Math.PI;

  // Facing angle: 0=right, +π/2=down, π=left, −π/2=up
  const facing = player.lastFacing || 0;

  ctx.save();
  ctx.translate(px, py);
  ctx.rotate(facing);

  ctx.fillStyle = CONFIG.colors.pac;
  ctx.beginPath();
  ctx.moveTo(0, 0);
  // Wedge oriented to +X (right) by default. Rotating by 'facing' yields correct orientation.
  ctx.arc(0, 0, ts * 0.48, mouth / 2, 2 * Math.PI - mouth / 2, false);
  ctx.closePath();
  ctx.fill();

  ctx.restore();
}

function drawLetters() {
  const ts = CONFIG.tileSize;
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.font = 'bold 18px Courier New';
  for (const L of gameState.letters) {
    if (L.state !== 'moving') continue;
    const px = L.x * ts, py = L.y * ts;
    ctx.fillStyle = '#fff';
    ctx.strokeStyle = '#111';
    ctx.lineWidth = 2;
    ctx.strokeText(L.glyph, px, py);
    ctx.fillText(L.glyph, px, py);

    const need = gameState.roundWord[gameState.progressIndex];
    if (L.glyph === need && CONFIG.showHint) {
      ctx.beginPath();
      ctx.arc(px, py, ts*0.55, 0, Math.PI*2);
      ctx.strokeStyle = '#ff0';
      ctx.lineWidth = 1;
      ctx.stroke();
    }
  }
}

/* -------- Timer & Loop -------- */
function stepTimer(dtMs) {
  gameState.timeLeftMs -= dtMs;
  if (gameState.timeLeftMs <= 0) {
    gameState.lives -= 1;
    if (gameState.lives <= 0) {
      gameState.lives = 0;
      gameState.running = false;
      msgEl.textContent = "Game Over — Press F5 to restart";
    } else {
      msgEl.textContent = "Time up! Lost a life; round reset";
      spawnRound(gameState.roundWord);
    }
    updateHUD();
  }
}

let lastTs = performance.now();
let acc = 0;
const FIXED_DT = 1/60;

function loop(ts) {
  if (!gameState.running) return drawFrame(0);
  requestAnimationFrame(loop);
  // Harden: cap dt to handle tab hiccups without tunneling through walls
  const dt = Math.min(0.05, (ts - lastTs)/1000);
  lastTs = ts;
  if (gameState.paused) return drawFrame(0);

  acc += dt;
  while (acc >= FIXED_DT) {
    stepPlayer(FIXED_DT);
    stepLetters(FIXED_DT);
    handleCollisions();
    stepTimer(FIXED_DT * 1000);
    acc -= FIXED_DT;
  }
  drawFrame(acc / FIXED_DT);
}

function drawFrame(alpha) {
  drawMaze();
  drawLetters();
  drawPlayer();
}

/* -------- Init -------- */
function start() {
  try { validateMap(); }
  catch (e) {
    // Harden: visible failure helps debugging bad map edits; still avoid external UI.
    console.error(e);
    msgEl.textContent = "MAP ERROR: " + e.message;
  }
  gameState.score = 0;
  gameState.lives = CONFIG.lives;
  spawnRound(CONFIG.words[0]);
  updateHUD();
  requestAnimationFrame(loop);
}

start();
</script>
</body>
</html>
