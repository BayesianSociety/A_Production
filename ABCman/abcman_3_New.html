<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>WordChomp — Pac-Man Letters (Local)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    /* Retro layout */
    html, body { height: 100%; }
    body {
      margin: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      background: #333;
      color: #0f0;
      font-family: "Courier New", Courier, monospace;
      user-select: none;
    }
    #game { text-align: center; }
    /* 28x31 tiles @ 16px => 448x496 canvas */
    canvas {
      width: 448px; height: 496px;
      border: 2px solid #000;
      background: #000;
      image-rendering: pixelated;
      image-rendering: crisp-edges;
      display: block;
      margin: 8px auto;
      cursor: crosshair; /* easier targeting for click-to-move */
    }
    #hud {
      display: flex;
      gap: 24px;
      justify-content: center;
      align-items: center;
      font-size: 18px;
      line-height: 1.2;
    }
    #wordBlanks { letter-spacing: 6px; }
    #msg { margin-top: 6px; min-height: 20px; color: #9f9; }
    .btn { color:#0f0; background:#111; border:1px solid #0f0; padding:4px 8px; cursor:pointer; }

    /* HUD pills & warnings */
    .pill { padding: 2px 8px; border:1px solid #0f0; border-radius: 10px; }
    .badge { display:inline-block; min-width:20px; text-align:center; border:1px solid #0f0; border-radius: 4px; padding: 0 6px; }
    #time.lowTime { color:#f66; border-color:#f66; }
    #wordBlanks span { display:inline-block; min-width: 14px; }
    #wordBlanks .done { color:#0f0; }
    #wordBlanks .todo { color:#090; }
    #next strong { font-size: 18px; }
  </style>
</head>
<body>
<div id="game">
  <div id="hud">
    <div id="score">Score: 0</div>
    <div id="lives">Lives: 3</div>
    <div id="time">Time: 00:00</div>
    <div id="next" title="Next required letter">Next: <span class="badge">?</span></div>
  </div>
  <canvas id="c" width="448" height="496"></canvas>
  <div id="wordBlanks">_ _ _</div>
  <div id="msg">Click a tunnel tile to move • P pause • H hint</div>
  <div>
    <button class="btn" id="toggleHint">Toggle Hint</button>
  </div>
</div>

<script>
'use strict';
/*
ASSUMPTIONS (explicit, per spec):
- EXACT 28x31 map below is authoritative. Tile values: 1=wall, 0=empty corridor, 2=pellet corridor (visual).
- Grid/tile contract: movement lanes are tile centers at (N + 0.5). Collision lookups use Math.floor(tileCoords).
- Letters must spawn and move ONLY on pellet tiles (value 2) and are always edible.
- The player must eat letters in the exact order of the active word; wrong-order contact only deducts score.
- Facing semantics: player.lastFacing is an angle in radians where 0=right, +π/2=down, π=left, −π/2=up.
  Rendering draws a wedge that inherently faces RIGHT; we rotate by lastFacing (no magic offsets).
- This change replaces arrow-key steering with **mouse click-to-move**: click a passable tunnel tile and the player
  auto-paths to it via shortest path (A*). A new click cancels the current path. Arrow keys are disabled in this mode.
- Pathfinding uses 4-neighbor grid with **horizontal wrap** (columns wrap), no vertical wrap. Heuristic = Manhattan with wrap.
- Implementation change to FIX oscillation: movement along a path is **segment-based**. We move to the EXACT next tile center,
  clamping the step so we never skip past centers. This removes back-and-forth jitter at 9 tiles/sec.
- Single file, no external libraries, must run via file:// in a modern browser.
*/

const CONFIG = {
  words: ["DOG","CAT","SCHOOL","CAR","TREE","HOUSE"],
  roundTimeMs: 90_000,
  letterSpeedTilesPerSec: 6,
  playerSpeedTilesPerSec: 9,
  lives: 3,
  penalties: { wrongLetter: 50 },
  rewards: { perCorrectLetter: 100, wordBonus: 500 },
  showHint: false,
  showWord: false,
  audio: { enabled: false },
  tileSize: 16,
  cols: 28,
  rows: 31,
  colors: { wall:"#00f", dot:"#fff", pac:"#ff0", text:"#0f0", bg:"#000", stroke:"#111" },
  mouseMode: true,         // click-to-move enabled
  showPathPreview: false,  // optional debug path lines (kept OFF per spec)
};

/* -------- Map (EXACTLY as provided) -------- */
const MAP = [
  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
  [1,2,2,2,2,2,2,2,2,2,2,2,2,1,1,2,2,2,2,2,2,2,2,2,2,2,2,1],
  [1,2,1,1,1,1,2,1,1,1,1,1,2,1,1,2,1,1,1,1,1,2,1,1,1,1,2,1],
  [1,2,1,0,0,1,2,1,0,0,0,1,2,1,1,2,1,0,0,0,1,2,1,0,0,1,2,1],
  [1,2,1,0,0,1,2,1,0,0,0,1,2,1,1,2,1,0,0,0,1,2,1,0,0,1,2,1],
  [1,2,1,1,1,1,2,1,1,1,1,1,2,1,1,2,1,1,1,1,1,2,1,1,1,1,2,1],
  [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1],
  [1,2,1,1,1,1,2,1,1,2,1,1,1,1,1,1,1,1,2,1,1,2,1,1,1,1,2,1],
  [1,2,1,1,1,1,2,1,1,2,1,1,1,1,1,1,1,1,2,1,1,2,1,1,1,1,2,1],
  [1,2,2,2,2,2,2,1,1,2,2,2,2,1,1,2,2,2,2,1,1,2,2,2,2,2,2,1],
  [1,1,1,1,1,1,2,1,1,1,1,1,0,1,1,0,1,1,1,1,1,2,1,1,1,1,1,1],
  [0,0,0,0,0,1,2,1,1,1,1,1,0,1,1,0,1,1,1,1,1,2,1,0,0,0,0,0],
  [0,0,0,0,0,1,2,1,1,0,0,0,0,0,0,0,0,0,0,1,1,2,1,0,0,0,0,0],
  [0,0,0,0,0,1,2,1,1,0,1,1,1,0,0,1,1,1,0,1,1,2,1,0,0,0,0,0],
  [1,1,1,1,1,1,2,1,1,0,1,0,0,0,0,0,0,1,0,1,1,2,1,1,1,1,1,1],
  [0,0,0,0,0,0,2,0,0,0,1,0,0,0,0,0,0,1,0,0,0,2,0,0,0,0,0,0],
  [1,1,1,1,1,1,2,1,1,0,1,0,0,0,0,0,0,1,0,1,1,2,1,1,1,1,1,1],
  [0,0,0,0,0,1,2,1,1,0,1,1,1,1,1,1,1,1,0,1,1,2,1,0,0,0,0,0],
  [0,0,0,0,0,1,2,1,1,0,0,0,0,0,0,0,0,0,0,1,1,2,1,0,0,0,0,0],
  [0,0,0,0,0,1,2,1,1,1,1,1,0,1,1,0,1,1,1,1,1,2,1,0,0,0,0,0],
  [1,1,1,1,1,1,2,1,1,1,1,1,0,1,1,0,1,1,1,1,1,2,1,1,1,1,1,1],
  [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1],
  [1,2,1,1,1,1,2,1,1,1,1,1,2,1,1,2,1,1,1,1,1,2,1,1,1,1,2,1],
  [1,2,1,1,1,1,2,1,1,1,1,1,2,1,1,2,1,1,1,1,1,2,1,1,1,1,2,1],
  [1,2,2,2,1,1,2,2,2,2,2,2,2,0,0,2,2,2,2,2,2,2,1,1,2,2,2,1],
  [1,1,1,2,1,1,2,1,1,2,1,1,1,1,1,1,1,1,2,1,1,2,1,1,2,1,1,1],
  [1,1,1,2,1,1,2,1,1,2,1,1,1,1,1,1,1,1,2,1,1,2,1,1,2,1,1,1],
  [1,2,2,2,2,2,2,1,1,2,2,2,2,1,1,2,2,2,2,1,1,2,2,2,2,2,2,1],
  [1,2,1,1,1,1,1,1,1,1,1,1,2,1,1,2,1,1,1,1,1,1,1,1,1,1,2,1],
  [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1],
  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
];

/* -------- Canvas & HUD -------- */
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
const scoreEl = document.getElementById('score');
const livesEl = document.getElementById('lives');
const timeEl = document.getElementById('time');
const blanksEl = document.getElementById('wordBlanks');
const nextEl = document.getElementById('next');
const msgEl = document.getElementById('msg');
document.getElementById('toggleHint').onclick = () => {
  CONFIG.showHint = !CONFIG.showHint;
  updateHUD();
};

/* -------- Utilities -------- */
const rnd = (() => { // deterministic LCG per round
  let s = 1234567;
  return {
    seed(v) { s = (v>>>0) || 1; },
    next() { s = (1103515245 * s + 12345) >>> 0; return s; },
    float() { return (rnd.next() % 10000) / 10000; },
    pick(arr) { return arr[(rnd.next() % arr.length)]; }
  };
})();

function clamp(v, lo, hi){ return Math.max(lo, Math.min(hi, v)); }
function tileCenter(v) { return Math.abs((v - Math.floor(v)) - 0.5) < 0.05; }
function dist2(ax,ay,bx,by) { const dx=ax-bx, dy=ay-by; return dx*dx+dy*dy; }
function fmtMMSS(totalSeconds){
  totalSeconds = Math.max(0, Math.floor(totalSeconds));
  const m = String(Math.floor(totalSeconds/60)).padStart(2,'0');
  const s = String(totalSeconds%60).padStart(2,'0');
  return `${m}:${s}`;
}
function renderBlanks(word, progress){
  const out = [];
  for(let i=0;i<word.length;i++){
    const ch = i < progress ? word[i] : '_';
    const cls = i < progress ? 'done' : 'todo';
    out.push(`<span class="${cls}">${ch}</span>`);
  }
  return out.join(' ');
}

/* -------- Map helpers (hardened) -------- */
function validateMap() {
  if (MAP.length !== CONFIG.rows) throw new Error("Map row count mismatch.");
  for (let y=0; y<CONFIG.rows; y++) {
    if (!Array.isArray(MAP[y]) || MAP[y].length !== CONFIG.cols) {
      throw new Error("Map column count mismatch at row " + y);
    }
    for (let x=0; x<CONFIG.cols; x++) {
      const t = MAP[y][x];
      if (t!==0 && t!==1 && t!==2) throw new Error("Invalid tile value at ("+x+","+y+")");
    }
  }
}
function isPassable(cx, cy) {
  if (cx < 0 || cx >= CONFIG.cols || cy < 0 || cy >= CONFIG.rows) return false;
  const t = MAP[cy][cx];
  return t === 0 || t === 2;
}
function isPellet(cx, cy) {
  if (cx < 0 || cx >= CONFIG.cols || cy < 0 || cy >= CONFIG.rows) return false;
  return MAP[cy][cx] === 2;
}
function canGo(x,y,dx,dy) {
  const cx = Math.floor(x);
  const cy = Math.floor(y);
  return isPassable(cx + dx, cy + dy);
}
function canGoPellet(x,y,dx,dy) {
  const cx = Math.floor(x);
  const cy = Math.floor(y);
  return isPellet(cx + dx, cy + dy);
}
function nearestPelletCenter(x, y, maxR=12) {
  const sx = Math.floor(x), sy = Math.floor(y);
  if (isPellet(sx, sy)) return [sx+0.5, sy+0.5];
  for (let r=1; r<=maxR; r++) {
    for (let dx=-r; dx<=r; dx++) {
      for (let dy=-r; dy<=r; dy++) {
        const tx = sx+dx, ty = sy+dy;
        if (isPellet(tx, ty)) return [tx+0.5, ty+0.5];
      }
    }
  }
  for (let yy=0; yy<CONFIG.rows; yy++) for (let xx=0; xx<CONFIG.cols; xx++) {
    if (isPellet(xx, yy)) return [xx+0.5, yy+0.5];
  }
  return [x, y];
}

/* -------- Grid helpers -------- */
function atCenter(x,y) { return tileCenter(x) && tileCenter(y); }
function alignToGrid(entity) {
  const eps = 0.15;
  const centerY = Math.floor(entity.y) + 0.5;
  const centerX = Math.floor(entity.x) + 0.5;
  if (Math.abs(entity.dx) > 0 && Math.abs(entity.y - centerY) < eps) entity.y = centerY;
  if (Math.abs(entity.dy) > 0 && Math.abs(entity.x - centerX) < eps) entity.x = centerX;
}

/* -------- Adjacency + Pathfinding (A* with horizontal wrap) -------- */
let ADJ = null;

function buildAdjacencyGraph() {
  const cols = CONFIG.cols, rows = CONFIG.rows;
  const pass = new Array(cols * rows).fill(false);
  const neighbors = new Array(cols * rows);
  const idx = (x,y)=> y*cols + x;
  for (let y=0; y<rows; y++) {
    for (let x=0; x<cols; x++) {
      const id = idx(x,y);
      pass[id] = isPassable(x,y);
      neighbors[id] = [];
    }
  }
  for (let y=0; y<rows; y++) {
    for (let x=0; x<cols; x++) {
      const id = idx(x,y);
      if (!pass[id]) continue;
      // right (wrap)
      const rx = (x+1) % cols;
      if (isPassable(rx, y)) neighbors[id].push(idx(rx,y));
      // left (wrap)
      const lx = (x-1+cols) % cols;
      if (isPassable(lx, y)) neighbors[id].push(idx(lx,y));
      // down
      if (y+1 < rows && isPassable(x, y+1)) neighbors[id].push(idx(x,y+1));
      // up
      if (y-1 >= 0 && isPassable(x, y-1)) neighbors[id].push(idx(x,y-1));
    }
  }
  return { neighbors, pass, cols, rows, idx };
}

function hWrap(x, y, gx, gy) {
  const dx = Math.abs(gx - x);
  const dxw = Math.min(dx, CONFIG.cols - dx);
  const dy = Math.abs(gy - y);
  return dxw + dy;
}

function astar(startCol, startRow, goalCol, goalRow) {
  const {neighbors, pass, cols, rows, idx} = ADJ;
  const start = idx(startCol, startRow);
  const goal  = idx(goalCol, goalRow);
  if (!pass[start] || !pass[goal]) return null;

  const open = [start];
  const inOpen = new Uint8Array(cols*rows); inOpen[start] = 1;
  const came = new Int32Array(cols*rows); came.fill(-1);
  const g = new Float32Array(cols*rows); g.fill(Infinity); g[start] = 0;
  const f = new Float32Array(cols*rows); f.fill(Infinity);
  f[start] = hWrap(startCol, startRow, goalCol, goalRow);
  const closed = new Uint8Array(cols*rows);

  function toXY(id){ return [id % cols, Math.floor(id / cols)]; }

  while (open.length) {
    // get node with lowest f
    let bestI = 0, best = open[0];
    for (let i=1;i<open.length;i++) { if (f[open[i]] < f[best]) { best = open[i]; bestI = i; } }
    const current = best;
    if (current === goal) {
      // reconstruct
      const pathIds = [];
      let cur = current;
      while (cur !== -1) { pathIds.push(cur); cur = came[cur]; }
      pathIds.reverse();
      // convert to [{x,y}]
      return pathIds.map(id => ({ x: id % cols, y: Math.floor(id / cols) }));
    }
    open.splice(bestI,1); inOpen[current] = 0; closed[current] = 1;

    const neigh = neighbors[current];
    for (let k=0;k<neigh.length;k++) {
      const nb = neigh[k];
      if (closed[nb]) continue;
      const tentative = g[current] + 1; // uniform cost
      if (!inOpen[nb]) {
        open.push(nb); inOpen[nb] = 1;
      } else if (tentative >= g[nb]) {
        continue;
      }
      came[nb] = current;
      g[nb] = tentative;
      const nx = nb % cols, ny = Math.floor(nb / cols);
      const [cx, cy] = toXY(current);
      f[nb] = g[nb] + hWrap(nx, ny, goalCol, goalRow);
    }
  }
  return null; // no route
}

function bfsNearestPassableReachable(clickCol, clickRow, fromCol, fromRow) {
  // BFS outward in taxicab metric order to find nearest passable cell
  const cols = CONFIG.cols, rows = CONFIG.rows;
  const q = [[clickCol, clickRow]];
  const seen = new Array(cols*rows).fill(0);
  const id = (x,y)=> y*cols + x;
  seen[id(clickCol, clickRow)] = 1;
  const dirs = [[1,0],[-1,0],[0,1],[0,-1]];
  while (q.length) {
    const [x,y] = q.shift();
    if (isPassable(x,y)) {
      // verify reachability from player
      const path = astar(fromCol, fromRow, x, y);
      if (path && path.length) return { x, y };
    }
    for (const [dx,dy] of dirs) {
      const nx = (x+dx+cols)%cols; // allow wrap during search so nearest across tunnel is picked naturally
      const ny = y+dy;
      if (ny < 0 || ny >= rows) continue; // no vertical wrap
      const nid = id(nx,ny);
      if (!seen[nid]) { seen[nid] = 1; q.push([nx,ny]); }
    }
  }
  return null;
}

/* -------- Mouse input: click-to-move -------- */
function screenToTile(px, py) {
  const col = clamp(Math.floor(px / CONFIG.tileSize), 0, CONFIG.cols-1);
  const row = clamp(Math.floor(py / CONFIG.tileSize), 0, CONFIG.rows-1);
  return { col, row };
}

function playerTile() {
  return { col: Math.floor(player.x), row: Math.floor(player.y) };
}

function setPathFromTo(startCol, startRow, goalCol, goalRow) {
  const path = astar(startCol, startRow, goalCol, goalRow);
  if (!path || path.length === 0) {
    player.path = [];
    player.segActive = false;
    return;
  }
  // Drop the first tile if it's the current tile; store remaining as waypoints (tile coords)
  if (path.length && path[0].x === startCol && path[0].y === startRow) path.shift();
  player.path = path; // [{x,y}, ...]
  player.segActive = false; // new path => next tick will pick first segment cleanly from the tile center
}

canvas.addEventListener('mousedown', (e)=>{
  if (!CONFIG.mouseMode) return;
  const rect = canvas.getBoundingClientRect();
  const x = e.clientX - rect.left;
  const y = e.clientY - rect.top;
  const { col, row } = screenToTile(x, y);
  const from = playerTile();
  let target = null;
  if (isPassable(col,row)) {
    target = { x: col, y: row };
  } else {
    target = bfsNearestPassableReachable(col, row, from.col, from.row);
  }
  if (!target) return;
  setPathFromTo(from.col, from.row, target.x, target.y);
  msgEl.textContent = player.path.length ? `Routing to (${target.x},${target.y})` : `Already there`;
});

/* -------- Entities -------- */
const gameState = {
  running: true,
  paused: false,
  lives: CONFIG.lives,
  score: 0,
  roundWord: "DOG",
  progressIndex: 0,
  timeLeftMs: CONFIG.roundTimeMs,
  letters: [],
};

const player = {
  // Central-ish default; spawn search ensures passable start even if this tile changes later.
  spawnX: 14.5, spawnY: 23.5,
  x: 14.5, y: 23.5, dx: 0, dy: 0, wantDx: 1, wantDy: 0,
  speed: CONFIG.playerSpeedTilesPerSec, anim: 0, lastFacing: 0,
  path: [],            // queue of waypoints as tile coordinates [{x,y}, ...]
  segActive: false,    // are we currently traversing a segment to a specific tile center?
  segDX: 0, segDY: 0,  // unit step along current segment (-1/0/1), cardinal only
  segTX: 0, segTY: 0   // target tile center (can be outside [0,cols) due to wrap; wrap applied after moving)
};

function isTilePassableCenter(tx, ty) { return isPassable(Math.floor(tx), Math.floor(ty)); }

function spawnPlayer() {
  // Find nearest passable tile center to the configured spawn.
  let sx = player.spawnX, sy = player.spawnY;
  if (!isTilePassableCenter(sx, sy)) {
    let found = false;
    for (let r=1; r<=8 && !found; r++) {
      for (let dx=-r; dx<=r && !found; dx++) {
        for (let dy=-r; dy<=r; dy++) {
          const tx = sx+dx, ty = sy+dy;
          if (isTilePassableCenter(tx, ty)) { sx = tx; sy = ty; found = true; break; }
        }
      }
    }
  }
  player.x = sx; player.y = sy;
  player.dx = 0; player.dy = 0;
  player.wantDx = 1; player.wantDy = 0;
  // Reset path/segment when spawning
  player.path = [];
  player.segActive = false;
}

/* -------- Round & HUD -------- */
function spawnRound(word) {
  word = String(word).toUpperCase();
  gameState.roundWord = word;
  gameState.progressIndex = 0;
  gameState.timeLeftMs = CONFIG.roundTimeMs;
  gameState.letters.length = 0;

  spawnPlayer();

  // Deterministic RNG seed from word
  let seed = 0;
  for (let i=0;i<word.length;i++) seed = (seed*131 + word.charCodeAt(i))>>>0;
  rnd.seed(seed);

  // Candidate spawns = pellet tiles only, away from player & other letters
  const candidates = [];
  for (let y=0;y<CONFIG.rows;y++) for (let x=0;x<CONFIG.cols;x++) {
    if (isPellet(x,y)) {
      const d = dist2(x+0.5,y+0.5, player.x, player.y);
      if (d > 9) candidates.push([x+0.5,y+0.5]);
    }
  }

  const placed = [];
  for (let i=0;i<word.length;i++) {
    let chosen = null;
    let tries = 0;
    while (tries++ < 40 && candidates.length) {
      const idx = rnd.next() % candidates.length;
      const p = candidates[idx];
      const okPlayer = dist2(p[0],p[1], player.x, player.y) >= 4.0; // >= 2 tiles
      const okOthers = placed.every(q => dist2(p[0],p[1], q[0], q[1]) >= 4.0);
      if (okPlayer && okOthers) { chosen = candidates.splice(idx,1)[0]; break; }
      else { candidates.splice(idx,1); }
    }
    if (!chosen) { chosen = nearestPelletCenter(14.5, 11.5); }
    placed.push(chosen);
    gameState.letters.push({
      glyph: word[i], order: i,
      x: chosen[0], y: chosen[1],
      dx: 0, dy: 0,
      speed: CONFIG.letterSpeedTilesPerSec,
      state: "moving",
      stuckTicks: 0
    });
  }

  for (const L of gameState.letters) chooseLetterDir(L, true);
  // Clear any pending auto-path on new round; user can re-click a destination.
  player.path = [];
  player.segActive = false;
  msgEl.textContent = 'New word!';
  updateHUD();
}

function updateHUD() {
  scoreEl.textContent = `Score: ${gameState.score}`;
  livesEl.textContent = `Lives: ${gameState.lives}`;
  const secs = Math.max(0, Math.floor(gameState.timeLeftMs/1000));
  timeEl.textContent = `Time: ${fmtMMSS(secs)}`;
  if (secs <= 10) timeEl.classList.add('lowTime'); else timeEl.classList.remove('lowTime');
  blanksEl.innerHTML = renderBlanks(gameState.roundWord, gameState.progressIndex);
  const nextSpan = document.querySelector('#next .badge');
  const nextCh = gameState.roundWord[gameState.progressIndex] || '?';
  nextSpan.textContent = CONFIG.showHint ? nextCh : '?';
  const btn = document.getElementById('toggleHint');
  btn.textContent = `Hint: ${CONFIG.showHint ? 'ON' : 'OFF'}`;
}

/* -------- Input -------- */
window.addEventListener('keydown', (e)=>{
  // Mouse mode replaces arrow steering; keep P/H hotkeys only.
  if (e.key.toLowerCase() === 'p') { gameState.paused = !gameState.paused; msgEl.textContent = gameState.paused ? 'PAUSED' : ''; }
  else if (e.key.toLowerCase() === 'h') { CONFIG.showHint = !CONFIG.showHint; updateHUD(); }
});

/* -------- Movement & Collisions -------- */
function wrapX(x) {
  // Horizontal wrap through tunnels; vertical wrap is not present in this maze.
  if (x < -0.5) return CONFIG.cols-0.5;
  if (x > CONFIG.cols-0.5) return 0.5;
  return x;
}

function chooseLetterDir(L, force=false) {
  if (!force && !atCenter(L.x, L.y)) return;
  const cx = Math.floor(L.x), cy = Math.floor(L.y);
  const dirs = [];
  const options = [[1,0],[-1,0],[0,1],[0,-1]];
  for (const [dx,dy] of options) {
    const nx = cx + dx, ny = cy + dy;
    if (isPellet(nx,ny)) {
      if (!(dx === -L.dx && dy === -L.dy)) dirs.push([dx,dy]);
    }
  }
  if (dirs.length === 0) {
    for (const [dx,dy] of options) if (isPellet(cx+dx, cy+dy)) { dirs.push([dx,dy]); }
  }
  if (dirs.length === 0) { L.dx = 0; L.dy = 0; return; }
  const pick = rnd.pick(dirs);
  L.dx = pick[0]; L.dy = pick[1];
}

function perpendicularDirs(dx, dy) {
  if (dx !== 0) return [[0,1],[0,-1]];
  if (dy !== 0) return [[1,0],[-1,0]];
  return [[1,0],[-1,0]];
}

function stepLetters(dt) {
  for (const L of gameState.letters) {
    if (L.state !== 'moving') continue;

    const prevX = L.x, prevY = L.y;

    alignToGrid(L);

    if (atCenter(L.x, L.y) && !canGoPellet(L.x, L.y, L.dx, L.dy)) {
      chooseLetterDir(L, true);
    }

    const spd = L.speed * dt;
    L.x += L.dx * spd;
    L.y += L.dy * spd;

    L.x = wrapX(L.x);

    if (!canGoPellet(L.x, L.y, L.dx, L.dy) && !atCenter(L.x, L.y)) {
      if (L.dx !== 0) L.x = Math.floor(L.x) + 0.5;
      if (L.dy !== 0) L.y = Math.floor(L.y) + 0.5;
      L.dx = L.dy = 0;
      chooseLetterDir(L, true);
    }

    if (atCenter(L.x, L.y) && (rnd.next() % 4 === 0)) {
      chooseLetterDir(L, false);
    }

    const moved2 = dist2(prevX, prevY, L.x, L.y);
    if (moved2 < 1e-6) {
      L.stuckTicks = (L.stuckTicks|0) + 1;
      if (L.stuckTicks > 10 && atCenter(L.x, L.y)) {
        chooseLetterDir(L, true);
        L.stuckTicks = 0;
      }
    } else {
      L.stuckTicks = 0;
    }
  }

  // Simple separation to avoid overlaps
  for (let i=0;i<gameState.letters.length;i++) {
    const A = gameState.letters[i];
    if (A.state !== 'moving') continue;
    for (let j=i+1;j<gameState.letters.length;j++) {
      const B = gameState.letters[j];
      if (B.state !== 'moving') continue;
      if (dist2(A.x,A.y,B.x,B.y) < 0.16) {
        const dirsA = perpendicularDirs(A.dx, A.dy).filter(([dx,dy]) => canGoPellet(A.x, A.y, dx, dy));
        const dirsB = perpendicularDirs(B.dx, B.dy).filter(([dx,dy]) => canGoPellet(B.x, B.y, dx, dy));
        if (dirsA.length) { const pa = rnd.pick(dirsA); A.dx = pa[0]; A.dy = pa[1]; }
        if (dirsB.length) { const pb = rnd.pick(dirsB); B.dx = pb[0]; B.dy = pb[1]; }
      }
    }
  }
}

function handleCollisions() {
  const need = gameState.roundWord[gameState.progressIndex];
  for (const L of gameState.letters) {
    if (L.state !== 'moving') continue;
    if (dist2(player.x, player.y, L.x, L.y) < 0.25) {
      if (L.glyph === need) {
        L.state = 'collected';
        gameState.progressIndex++;
        gameState.score += CONFIG.rewards.perCorrectLetter;
        msgEl.textContent = `Good! Collected '${L.glyph}'`;
        if (gameState.progressIndex >= gameState.roundWord.length) {
          gameState.score += CONFIG.rewards.wordBonus;
          msgEl.textContent = `Word complete: ${gameState.roundWord}! +${CONFIG.rewards.wordBonus}`;
          const nextWord = CONFIG.words[(CONFIG.words.indexOf(gameState.roundWord)+1) % CONFIG.words.length];
          spawnRound(nextWord);
        }
        updateHUD();
      } else {
        gameState.score = Math.max(0, gameState.score - CONFIG.penalties.wrongLetter);
        msgEl.textContent = `Wrong order! Need '${need}'`;
        updateHUD();
      }
    }
  }
}

/* ======== SEGMENT-BASED PLAYER PATH FOLLOWING (FIXES JITTER/LOOPS) ======== */
function beginNextSegmentFromCenter() {
  // Requires: player is EXACTLY at a tile center (x=.5, y=.5 in tile space)
  // If there is a pending path waypoint, create a segment to the next tile center.
  if (!player.path.length) { player.segActive = false; return; }

  const cx = Math.floor(player.x), cy = Math.floor(player.y);
  // If the first waypoint equals current tile, drop it.
  if (player.path[0].x === cx && player.path[0].y === cy) {
    player.path.shift();
    if (!player.path.length) { player.segActive = false; return; }
  }

  const nx = player.path[0].x, ny = player.path[0].y;

  // Determine cardinal direction with horizontal wrap allowed.
  if (ny === cy) {
    // horizontal move
    if (nx === (cx+1)%CONFIG.cols) { player.segDX = 1;  player.segDY = 0; }
    else if (nx === (cx-1+CONFIG.cols)%CONFIG.cols) { player.segDX = -1; player.segDY = 0; }
    else { player.segActive = false; player.path = []; return; } // invalid adjacency
  } else if (nx === cx) {
    // vertical move (no wrap)
    if (ny === cy+1) { player.segDX = 0; player.segDY = 1; }
    else if (ny === cy-1) { player.segDX = 0; player.segDY = -1; }
    else { player.segActive = false; player.path = []; return; } // invalid adjacency
  } else {
    // Not axis-aligned — invalid path
    player.segActive = false; player.path = []; return;
  }

  // Compute target center for this segment. Use current tile center + (dx,dy)*1.0
  const centerX = cx + 0.5, centerY = cy + 0.5;
  player.segTX = centerX + player.segDX * 1.0; // may be < -0.5 or > cols-0.5; wrap will fix post-move
  player.segTY = centerY + player.segDY * 1.0;

  // Apply heading
  player.dx = player.segDX; player.dy = player.segDY;
  player.segActive = true;

  // Update facing immediately for visual responsiveness
  player.lastFacing = Math.atan2(player.dy, player.dx);
}

function stepPlayer(dt) {
  alignToGrid(player);

  if (CONFIG.mouseMode) {
    // If we don't have an active segment: either move to our current tile center, or start the next segment.
    const cx = Math.floor(player.x), cy = Math.floor(player.y);
    const centerX = cx + 0.5, centerY = cy + 0.5;
    const atCenterNow = (Math.abs(player.x - centerX) < 1e-6) && (Math.abs(player.y - centerY) < 1e-6);

    if (!player.segActive) {
      if (!atCenterNow) {
        // First, snap-move towards the current tile center as a mini-segment (so we always start real segments from exact centers)
        const dx = Math.sign(centerX - player.x), dy = Math.sign(centerY - player.y);
        player.segDX = Math.abs(centerX - player.x) >= Math.abs(centerY - player.y) ? dx : 0;
        player.segDY = player.segDX ? 0 : dy;
        player.segTX = centerX;
        player.segTY = centerY;
        player.dx = player.segDX; player.dy = player.segDY;
        player.segActive = true;
        player.lastFacing = Math.atan2(player.dy, player.dx);
      } else if (player.path.length) {
        beginNextSegmentFromCenter();
      } else {
        // idle
        player.dx = player.dy = 0;
      }
    }

    // If we have an active segment, advance EXACTLY up to the target center (no overshoot)
    if (player.segActive) {
      const spd = player.speed * dt;
      if (player.segDX !== 0) {
        // horizontal move; handle wrap only after hitting target
        const remaining = player.segTX - player.x; // may be negative if moving left
        const step = Math.sign(remaining) * Math.min(Math.abs(remaining), spd);
        player.x += step;
        if (Math.abs(player.segTX - player.x) <= 1e-6) {
          // reached; lock exact, wrap, clear/pick next
          player.x = player.segTX;
          player.x = wrapX(player.x);
          player.segActive = false;
          // Consumed a tile: if we were moving to a waypoint center, pop it
          const nowCX = Math.floor(player.x), nowCY = Math.floor(player.y);
          if (player.path.length && nowCX === player.path[0].x && nowCY === player.path[0].y) {
            player.path.shift();
          }
          // Immediately begin next segment if path remains
          beginNextSegmentFromCenter();
        }
      } else if (player.segDY !== 0) {
        // vertical move (no wrap)
        const remaining = player.segTY - player.y;
        const step = Math.sign(remaining) * Math.min(Math.abs(remaining), spd);
        player.y += step;
        if (Math.abs(player.segTY - player.y) <= 1e-6) {
          player.y = player.segTY;
          player.segActive = false;
          const nowCX = Math.floor(player.x), nowCY = Math.floor(player.y);
          if (player.path.length && nowCX === player.path[0].x && nowCY === player.path[0].y) {
            player.path.shift();
          }
          beginNextSegmentFromCenter();
        }
      }
    }
  }

  // Advance mouth animation (purely visual)
  const moving = (Math.abs(player.dx) + Math.abs(player.dy)) > 0;
  const speedFactor = moving ? 1 : 0.5;
  player.anim += dt * 10 * speedFactor;
}

/* -------- Rendering -------- */
function drawMaze() {
  const ts = CONFIG.tileSize;
  ctx.fillStyle = CONFIG.colors.bg;
  ctx.fillRect(0,0,canvas.width,canvas.height);

  // Pellets (visual only)
  ctx.fillStyle = CONFIG.colors.dot;
  for (let y=0; y<CONFIG.rows; y++) {
    for (let x=0; x<CONFIG.cols; x++) {
      if (MAP[y][x] === 2) {
        ctx.beginPath();
        ctx.arc(x*ts+ts/2, y*ts+ts/2, 2, 0, Math.PI*2);
        ctx.fill();
      }
    }
  }

  // Walls
  ctx.fillStyle = CONFIG.colors.wall;
  for (let y=0; y<CONFIG.rows; y++) {
    for (let x=0; x<CONFIG.cols; x++) {
      if (MAP[y][x] === 1) {
        ctx.fillRect(x*ts, y*ts, ts, ts);
      }
    }
  }

  // Optional path preview (OFF by default)
  if (CONFIG.showPathPreview && player.path.length) {
    const ts2 = CONFIG.tileSize;
    ctx.strokeStyle = '#6ff';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo((Math.floor(player.x)+0.5)*ts2, (Math.floor(player.y)+0.5)*ts2);
    for (const wp of player.path) {
      ctx.lineTo((wp.x+0.5)*ts2, (wp.y+0.5)*ts2);
    }
    ctx.stroke();
  }
}

function drawPlayer() {
  const ts = CONFIG.tileSize;
  const px = player.x * ts, py = player.y * ts;

  // Mouth aperture (0 .. ~0.5π)
  const mouth = (Math.sin(player.anim) * 0.25 + 0.25) * Math.PI;

  // Facing angle: 0=right, +π/2=down, π=left, −π/2=up
  const facing = player.lastFacing || 0;

  ctx.save();
  ctx.translate(px, py);
  ctx.rotate(facing);

  ctx.fillStyle = CONFIG.colors.pac;
  ctx.beginPath();
  ctx.moveTo(0, 0);
  // Wedge oriented to +X (right) by default. Rotating by 'facing' yields correct orientation.
  ctx.arc(0, 0, ts * 0.48, mouth / 2, 2 * Math.PI - mouth / 2, false);
  ctx.closePath();
  ctx.fill();

  ctx.restore();
}

function drawLetters() {
  const ts = CONFIG.tileSize;
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.font = `bold 18px "Courier New", monospace`; // slightly larger for visibility
  for (const L of gameState.letters) {
    if (L.state !== 'moving') continue;
    const px = L.x * ts, py = L.y * ts;

    // double outline + fill for strong contrast
    ctx.lineWidth = 4; ctx.strokeStyle = '#000'; ctx.strokeText(L.glyph, px, py);
    ctx.lineWidth = 2; ctx.strokeStyle = '#111'; ctx.strokeText(L.glyph, px, py);
    ctx.fillStyle = '#fff'; ctx.fillText(L.glyph, px, py);

    const need = gameState.roundWord[gameState.progressIndex];
    if (L.glyph === need && CONFIG.showHint) {
      ctx.beginPath();
      ctx.arc(px, py, ts*0.55, 0, Math.PI*2);
      ctx.strokeStyle = '#ff0';
      ctx.lineWidth = 1;
      ctx.stroke();
    }
  }
}

/* -------- Timer & Loop -------- */
function stepTimer(dtMs) {
  gameState.timeLeftMs -= dtMs;
  if (gameState.timeLeftMs <= 0) {
    gameState.lives -= 1;
    if (gameState.lives <= 0) {
      gameState.lives = 0;
      gameState.running = false;
      msgEl.textContent = "Game Over — Press F5 to restart";
    } else {
      msgEl.textContent = "Time up! Lost a life; round reset";
      spawnRound(gameState.roundWord);
    }
    updateHUD();
  }
}

let lastTs = performance.now();
let acc = 0;
const FIXED_DT = 1/60;

function loop(ts) {
  if (!gameState.running) return drawFrame(0);
  requestAnimationFrame(loop);
  const dt = Math.min(0.05, (ts - lastTs)/1000);
  lastTs = ts;
  if (gameState.paused) return drawFrame(0);

  acc += dt;
  while (acc >= FIXED_DT) {
    stepPlayer(FIXED_DT);
    stepLetters(FIXED_DT);
    handleCollisions();
    stepTimer(FIXED_DT * 1000);
    acc -= FIXED_DT;
  }
  drawFrame(acc / FIXED_DT);
}

function drawFrame(alpha) {
  drawMaze();
  drawLetters();
  drawPlayer();
}

/* -------- Init -------- */
function start() {
  try { validateMap(); }
  catch (e) {
    console.error(e);
    msgEl.textContent = "MAP ERROR: " + e.message;
  }
  ADJ = buildAdjacencyGraph();
  gameState.score = 0;
  gameState.lives = CONFIG.lives;
  spawnRound(CONFIG.words[0]);
  updateHUD();
  requestAnimationFrame(loop);
}

start();
</script>
</body>
</html>
