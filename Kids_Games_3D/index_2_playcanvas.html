<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Cube Collector — PlayCanvas</title>
<style>
  html, body { margin: 0; height: 100%; overflow: hidden; font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Arial, sans-serif; }
  #app { width: 100vw; height: 100vh; display: block; }
  #ui { position: fixed; top: 12px; left: 12px; background: rgba(0,0,0,.55); color: #fff; padding: 8px 12px; border-radius: 12px; font-size: 14px; line-height: 1.3; z-index: 10; }
</style>
</head>
<body>
  <div id="ui">
    <div><b>Cube Collector</b> · PlayCanvas</div>
    <div>Score: <span id="score">0</span></div>
    <div>Move: WASD / Arrow Keys</div>
  </div>
  <canvas id="app"></canvas>

  <script src="https://code.playcanvas.com/playcanvas-stable.min.js"></script>
  <script>
    // Init
    const canvas = document.getElementById('app');
    const app = new pc.Application(canvas, { graphicsDeviceOptions: { antialias: true } });
    app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);
    app.setCanvasResolution(pc.RESOLUTION_AUTO);
    window.addEventListener('resize', () => app.resizeCanvas());

    // Input (create a keyboard handler)
    const keyboard = new pc.Keyboard(window);

    // Scene / lighting
    app.scene.ambientLight = new pc.Color(0.4, 0.4, 0.4);
    const light = new pc.Entity('light');
    light.addComponent('light', { type: 'directional', color: new pc.Color(1,1,1), castShadows: false });
    light.setLocalEulerAngles(45, 30, 0);
    app.root.addChild(light);

    // Camera
    const camera = new pc.Entity('camera');
    camera.addComponent('camera', { fov: 60, clearColor: new pc.Color(0.125, 0.157, 0.204) });
    camera.setLocalPosition(0, 6, 10);
    app.root.addChild(camera);

    // Ground
    const ground = new pc.Entity('ground');
    ground.addComponent('render', { type: 'box' });
    ground.setLocalScale(20, 0.1, 20);
    const gMat = new pc.StandardMaterial();
    gMat.diffuse = new pc.Color(0.165, 0.616, 0.561); gMat.update();
    ground.render.meshInstances[0].material = gMat;
    ground.setLocalPosition(0, -0.05, 0);
    app.root.addChild(ground);

    // Player (cube)
    const PLAYER_SIZE = 1;
    const player = new pc.Entity('player');
    player.addComponent('render', { type: 'box' });
    const pMat = new pc.StandardMaterial();
    pMat.diffuse = new pc.Color(1.0, 0.765, 0.188); pMat.update();
    player.render.meshInstances[0].material = pMat;
    player.setLocalPosition(0, 0.5, 0);
    app.root.addChild(player);

    // Coin (sphere)
    const COIN_R = 0.35;
    const coin = new pc.Entity('coin');
    coin.addComponent('render', { type: 'sphere' });
    coin.setLocalScale(0.7, 0.7, 0.7);
    const cMat = new pc.StandardMaterial();
    cMat.diffuse = new pc.Color(0.969, 0.145, 0.522);
    cMat.emissive = new pc.Color(0.2, 0.05, 0.15); cMat.update();
    coin.render.meshInstances[0].material = cMat;
    app.root.addChild(coin);

    // Helpers
    const bounds = 9;
    const randomPos = () => (Math.random() * 2 - 1) * bounds * 0.9;
    const respawnCoin = () => coin.setLocalPosition(randomPos(), 0.35, randomPos());
    respawnCoin();

    // Movement state
    const vel = new pc.Vec3(0, 0, 0);
    const speed = 6;
    const friction = 6;
    let score = 0; const scoreEl = document.getElementById('score');

    const clamp = (v, a, b) => Math.max(a, Math.min(b, v));

    app.on('update', (dt) => {
      dt = Math.min(0.05, dt);

      // Input
      let ax = 0, az = 0;
      if (keyboard.isPressed(pc.KEY_W) || keyboard.isPressed(pc.KEY_UP))    az -= 1;
      if (keyboard.isPressed(pc.KEY_S) || keyboard.isPressed(pc.KEY_DOWN))  az += 1;
      if (keyboard.isPressed(pc.KEY_A) || keyboard.isPressed(pc.KEY_LEFT))  ax -= 1;
      if (keyboard.isPressed(pc.KEY_D) || keyboard.isPressed(pc.KEY_RIGHT)) ax += 1;

      if (ax || az) {
        const len = Math.hypot(ax, az) || 1;
        vel.x += (ax / len) * speed * dt;
        vel.z += (az / len) * speed * dt;
      }
      // friction
      vel.x -= vel.x * Math.min(1, friction * dt);
      vel.z -= vel.z * Math.min(1, friction * dt);

      // integrate + clamp
      const p = player.getLocalPosition();
      p.x = clamp(p.x + vel.x * dt, -bounds, bounds);
      p.z = clamp(p.z + vel.z * dt, -bounds, bounds);
      player.setLocalPosition(p);

      // coin spin
      const eul = coin.getLocalEulerAngles();
      eul.z += 120 * dt; // degrees/sec
      coin.setLocalEulerAngles(eul);

      // collision (2D distance in XZ)
      const cp = coin.getLocalPosition();
      const dx = p.x - cp.x, dz = p.z - cp.z;
      const dist = Math.hypot(dx, dz);
      if (dist < PLAYER_SIZE * 0.6 + COIN_R) {
        score++; scoreEl.textContent = score;
        respawnCoin();
      }

      // camera follow (smooth)
      const target = p.clone().add(new pc.Vec3(0, 2, 5));
      const camPos = camera.getLocalPosition();
      // camPos = lerp(camPos, target, t)
      camPos.lerp(camPos, target, 1 - Math.pow(0.001, dt));
      camera.setLocalPosition(camPos);
      camera.lookAt(player.getPosition());
    });

    // Start the app!
    app.start();
  </script>
</body>
</html>
