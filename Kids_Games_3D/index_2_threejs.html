<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Cube Collector — Three.js</title>
  <style>
    html, body { margin: 0; height: 100%; overflow: hidden; font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Arial, sans-serif; }
    canvas { display: block; width: 100vw; height: 100vh; }
    #ui { position: fixed; top: 12px; left: 12px; background: rgba(0,0,0,.55); color: #fff; padding: 8px 12px; border-radius: 12px; font-size: 14px; line-height: 1.3; }
    #ui b { font-weight: 700; }
  </style>
</head>
<body>
  <div id="ui">
    <div><b>Cube Collector</b> · Three.js</div>
    <div>Score: <span id="score">0</span></div>
    <div>Move: WASD / Arrow Keys</div>
  </div>
  <canvas id="c"></canvas>

  <script type="module">
    // Use a direct ESM URL for Three.js
    import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';

    const canvas = document.getElementById('c');
    const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
    renderer.setPixelRatio(Math.min(2, window.devicePixelRatio || 1));
    renderer.setSize(window.innerWidth, window.innerHeight);

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x202834);

    const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 200);
    camera.position.set(0, 6, 10);

    // Lights
    scene.add(new THREE.AmbientLight(0xffffff, 0.6));
    const dir = new THREE.DirectionalLight(0xffffff, 0.8);
    dir.position.set(5, 10, 2);
    scene.add(dir);

    // Ground
    const ground = new THREE.Mesh(
      new THREE.PlaneGeometry(20, 20),
      new THREE.MeshPhongMaterial({ color: 0x2a9d8f })
    );
    ground.rotation.x = -Math.PI / 2;
    scene.add(ground);

    // Player cube
    const PLAYER_SIZE = 1;
    const player = new THREE.Mesh(
      new THREE.BoxGeometry(PLAYER_SIZE, PLAYER_SIZE, PLAYER_SIZE),
      new THREE.MeshStandardMaterial({ color: 0xffc300, metalness: 0.2, roughness: 0.6 })
    );
    player.position.y = PLAYER_SIZE / 2;
    scene.add(player);

    // Coin (torus)
    const COIN_R = 0.35;
    const coin = new THREE.Mesh(
      new THREE.TorusGeometry(COIN_R, 0.15, 12, 24),
      new THREE.MeshStandardMaterial({ color: 0xf72585, emissive: 0x220011 })
    );
    coin.rotation.x = Math.PI / 2;
    scene.add(coin);

    // Helpers
    const bounds = 9;
    function randomPos() { return (Math.random() * 2 - 1) * bounds * 0.9; }
    function respawnCoin() { coin.position.set(randomPos(), 0.35, randomPos()); }
    respawnCoin();

    // Input
    const keys = {};
    addEventListener('keydown', (e) => keys[e.key.toLowerCase()] = true);
    addEventListener('keyup',   (e) => keys[e.key.toLowerCase()] = false);

    // Motion + UI
    const vel = new THREE.Vector3();
    const speed = 6;
    const friction = 6;
    const scoreEl = document.getElementById('score');
    let score = 0;

    const clamp = (v, a, b) => Math.max(a, Math.min(b, v));

    let last = performance.now() / 1000;
    function loop() {
      const now = performance.now() / 1000;
      const dt = Math.min(0.05, now - last);
      last = now;

      // Input → acceleration
      let ax = 0, az = 0;
      if (keys['w'] || keys['arrowup'])    az -= 1;
      if (keys['s'] || keys['arrowdown'])  az += 1;
      if (keys['a'] || keys['arrowleft'])  ax -= 1;
      if (keys['d'] || keys['arrowright']) ax += 1;

      if (ax || az) {
        const len = Math.hypot(ax, az) || 1;
        vel.x += (ax / len) * speed * dt;
        vel.z += (az / len) * speed * dt;
      }
      // friction
      vel.x -= vel.x * Math.min(1, friction * dt);
      vel.z -= vel.z * Math.min(1, friction * dt);

      // integrate + clamp
      player.position.x = clamp(player.position.x + vel.x * dt, -bounds, bounds);
      player.position.z = clamp(player.position.z + vel.z * dt, -bounds, bounds);

      // coin spin + collision
      coin.rotation.z += 2 * dt;
      if (player.position.distanceTo(coin.position) < PLAYER_SIZE * 0.6 + COIN_R) {
        score++; scoreEl.textContent = score;
        respawnCoin();
      }

      // camera follow (smooth)
      const target = new THREE.Vector3().copy(player.position).add(new THREE.Vector3(0, 2, 5));
      camera.position.lerp(target, 1 - Math.pow(0.001, dt));
      camera.lookAt(player.position);

      renderer.render(scene, camera);
      requestAnimationFrame(loop);
    }
    loop();

    // Resize
    addEventListener('resize', () => {
      const w = innerWidth, h = innerHeight;
      camera.aspect = w / h;
      camera.updateProjectionMatrix();
      renderer.setSize(w, h);
    });
  </script>
</body>
</html>
