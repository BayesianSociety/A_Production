<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>C64-Style Pac-Man â€” Clean & Smooth</title>
  <style>
    body { background:#000; color:#fff; text-align:center; font-family:monospace; }
    #gameCanvas { display:block; margin:40px auto 10px; border:4px solid #120485; background:#001; }
  </style>
</head>
<body>
  <h1>C64-Style Pac-Man</h1>
  <canvas id="gameCanvas" width="640" height="480"></canvas>
  <p>Arrow keys to move. Eat all pellets!</p>

  <script>
  // ===== C64 palette =====
  const COLORS = {
    wall:"#120485", background:"#000", pacman:"#ffe800",
    ghostRed:"#f44336", ghostPink:"#e91e63", ghostCyan:"#00e6e6", ghostOrange:"#ff9800",
    pellet:"#fff", powerPellet:"#ffb6ff", fruit:"#43ff00", hudText:"#fff"
  };

  // ===== Globals =====
  let canvas, ctx;
  let maze, ROWS, COLS;
  let score, lives, level, gameState;
  let pacman;
  let ghosts = [];
  let ghostStarts = [];
  let pacmanStart;

  // timing: fixed-timestep + render interpolation
  const LOGIC_STEP = 120; // keep original speed per tile, but make it consistent
  let lastLogicTime = 0;
  let renderAlpha = 0;

  // modes & fruit
  let ghostModeTimer = 0, modeInterval = 7000;
  let powerFleeTimer = 0;
  let fruitVisible = false, fruitTimer = 0;
  const fruitSpawnInterval = 18000, fruitDuration = 6000;
  let fruitCell = null;

  // ===== Boot =====
  window.onload = () => {
    canvas = document.getElementById("gameCanvas");
    ctx = canvas.getContext("2d");
    setupGame();
    requestAnimationFrame(gameLoop);
  };

  function setupGame() {
    score = 0; lives = 3; level = 1; gameState = "playing";
    initMaze();            // rectangular map (21x28), includes tunnel row
    seedPelletsAndSpecials();
    initActors();
  }

  // ===== Maze =====
  function initMaze() {
    // 21 rows x 28 cols, symmetric; W=wall, .=floor, T=tunnel at ends
    const layout = [
      "WWWWWWWWWWWWWWWWWWWWWWWWWWWW",
      "W............WW............W",
      "W.WWWW..WW..WW..WW..WWWWWW.W",
      "W.W..WW..WW......WW..WW..W.W",
      "W.WWWW..WW..WW..WW..WWWWWW.W",
      "W............WW............W",
      "W.WW..WW....WWWW....WW..WW.W",
      "W.WWWW..WW..WW..WW..WWWWWW.W",
      "W............WW............W",
      "W.W..WW..WW......WW..WW..W.W",
      "T............WW............T", // warp tunnel row
      "W.W..WW..WW......WW..WW..W.W",
      "W............WW............W",
      "W.WWWW..WW..WW..WW..WWWWWW.W",
      "W.WW..WW....WWWW....WW..WW.W",
      "W............WW............W",
      "W.WWWW..WW..WW..WW..WWWWWW.W",
      "W.W..WW..WW......WW..WW..W.W",
      "W.WWWW..WW..WW..WW..WWWWWW.W",
      "W............WW............W",
      "WWWWWWWWWWWWWWWWWWWWWWWWWWWW"
    ];
    maze = layout.map(r => r.split(""));
    ROWS = maze.length;
    COLS = maze[0].length;
  }

  function seedPelletsAndSpecials() {
    // turn every floor into a pellet, place 4 power pellets near corners
    for (let r = 0; r < ROWS; r++) {
      for (let c = 0; c < COLS; c++) {
        if (maze[r][c] === ".") maze[r][c] = "P";
      }
    }
    const corners = [[1,1],[1,COLS-2],[ROWS-2,1],[ROWS-2,COLS-2]];
    corners.forEach(([r,c]) => { if (maze[r][c] !== "W") maze[r][c] = "O"; });

    fruitCell = findNearestFloor(Math.floor(ROWS/2), Math.floor(COLS/2));
  }

  // ===== Actors =====
  function initActors() {
    pacmanStart = findNearestFloor(16, 14);
    pacman = {
      row: pacmanStart.row, col: pacmanStart.col,
      prevRow: pacmanStart.row, prevCol: pacmanStart.col,
      direction: "left", nextDirection: "left"
    };

    ghostStarts = [
      findNearestFloor(11, 13),
      findNearestFloor(11, 14),
      findNearestFloor(11, 15),
      findNearestFloor(9, 13)
    ];
    ghosts = [
      mkGhost("blinky", COLORS.ghostRed,    ghostStarts[0], "left",  "chase"),
      mkGhost("pinky",  COLORS.ghostPink,   ghostStarts[1], "up",    "scatter"),
      mkGhost("inky",   COLORS.ghostCyan,   ghostStarts[2], "right", "scatter"),
      mkGhost("clyde",  COLORS.ghostOrange, ghostStarts[3], "down",  "scatter")
    ];
  }

  function mkGhost(name, color, start, dir, mode) {
    return {
      name, color,
      row: start.row, col: start.col,
      prevRow: start.row, prevCol: start.col,
      direction: dir, mode
    };
  }

  function findNearestFloor(sr, sc) {
    const pass = new Set(["P","O","T",".","F"]);
    let rad = 0;
    while (rad < Math.max(ROWS, COLS)) {
      for (let dr = -rad; dr <= rad; dr++) {
        for (let dc = -rad; dc <= rad; dc++) {
          const r = sr + dr, c = sc + dc;
          if (r>=0 && r<ROWS && c>=0 && c<COLS && pass.has(maze[r][c])) return {row:r,col:c};
        }
      }
      rad++;
    }
    return {row:1,col:1};
  }

  // ===== Loop (fixed timestep + interpolation) =====
  function gameLoop() {
    const now = performance.now();
    if (!lastLogicTime) lastLogicTime = now;

    let elapsed = now - lastLogicTime;

    while (elapsed >= LOGIC_STEP) {
      if (gameState === "playing") updateGame();
      lastLogicTime += LOGIC_STEP;
      elapsed -= LOGIC_STEP;
    }
    renderAlpha = elapsed / LOGIC_STEP;

    drawGame();
    requestAnimationFrame(gameLoop);
  }

  // ===== Logic =====
  function updateGame() {
    movePacman();
    updateGhostModes();
    ghosts.forEach(g => moveGhost(g));
    handleFruitSpawning();
    handlePelletEating();
    handleFruitEating();
    handleGhostCollision();

    if (powerFleeTimer && performance.now() - powerFleeTimer > 5000) {
      ghosts.forEach(g => { if (g.mode === "flee") g.mode = "chase"; });
      powerFleeTimer = 0;
    }
    if (maze.flat().every(ch => ch !== "P" && ch !== "O")) {
      level++;
      seedPelletsAndSpecials();
      resetPositions(true); // keep map, reset actors
    }
  }

  // ===== Input =====
  document.addEventListener("keydown", (e) => {
    const keyMap = {ArrowUp:"up", ArrowDown:"down", ArrowLeft:"left", ArrowRight:"right"};
    if (gameState === "playing" && keyMap[e.key]) pacman.nextDirection = keyMap[e.key];
    if (gameState === "gameover" && e.key === " ") { score = 0; level = 1; seedPelletsAndSpecials(); resetPositions(true); gameState="playing"; }
  });

  // ===== Movement =====
  function tryMove(row, col, dir) {
    const d = {up:[-1,0], down:[1,0], left:[0,-1], right:[0,1]}[dir] || [0,0];
    const nr = row + d[0], nc = col + d[1];
    if (nr>=0 && nr<ROWS && nc>=0 && nc<COLS && maze[nr][nc] !== "W") return {valid:true,row:nr,col:nc};
    return {valid:false,row,col};
  }

  function movePacman() {
    // remember previous position for interpolation
    pacman.prevRow = pacman.row; pacman.prevCol = pacman.col;

    let m = tryMove(pacman.row, pacman.col, pacman.nextDirection);
    if (m.valid) {
      pacman.direction = pacman.nextDirection;
      pacman.row = m.row; pacman.col = m.col;
    } else {
      m = tryMove(pacman.row, pacman.col, pacman.direction);
      if (m.valid) { pacman.row = m.row; pacman.col = m.col; }
    }

    // warp tunnels when on 'T' at ends
    if (maze[pacman.row][pacman.col] === "T") {
      if (pacman.col === 0) pacman.col = COLS - 2;
      else if (pacman.col === COLS - 1) pacman.col = 1;
    }
  }

  function moveGhost(g) {
    g.prevRow = g.row; g.prevCol = g.col;

    let target;
    if (g.mode === "scatter") {
      const corners = [{row:0,col:COLS-1},{row:0,col:0},{row:ROWS-1,col:COLS-1},{row:ROWS-1,col:0}];
      target = corners[ghosts.indexOf(g)] || corners[0];
    } else if (g.mode === "chase") {
      target = {row:pacman.row, col:pacman.col};
    } else {
      target = {row:ROWS-1-pacman.row, col:COLS-1-pacman.col};
    }

    const dirs = ["up","down","left","right"];
    let bestDir = g.direction, best = Infinity;
    for (const d of dirs) {
      const t = tryMove(g.row, g.col, d);
      if (t.valid) {
        const dist = Math.abs(t.row - target.row) + Math.abs(t.col - target.col);
        const reverse = (g.direction==="up"&&d==="down")||(g.direction==="down"&&d==="up")||(g.direction==="left"&&d==="right")||(g.direction==="right"&&d==="left");
        const penalty = reverse ? 0.1 : 0;
        if (dist + penalty < best) { best = dist + penalty; bestDir = d; }
      }
    }
    const nxt = tryMove(g.row, g.col, bestDir);
    if (nxt.valid) { g.row = nxt.row; g.col = nxt.col; g.direction = bestDir; }
  }

  function updateGhostModes() {
    const now = performance.now();
    if (!ghostModeTimer) ghostModeTimer = now;
    if (now - ghostModeTimer > modeInterval) {
      ghosts.forEach(g => g.mode = (g.mode === "scatter") ? "chase" : "scatter");
      ghostModeTimer = now;
    }
  }

  // ===== Collectibles =====
  function handlePelletEating() {
    const ch = maze[pacman.row][pacman.col];
    if (ch === "P") { maze[pacman.row][pacman.col] = "."; score += 10; }
    else if (ch === "O") { maze[pacman.row][pacman.col] = "."; score += 50; ghosts.forEach(g=>g.mode="flee"); powerFleeTimer = performance.now(); }
  }

  function handleFruitSpawning() {
    const now = performance.now();
    if (!fruitVisible && now - fruitTimer > fruitSpawnInterval) {
      if (fruitCell && maze[fruitCell.row][fruitCell.col] !== "W") {
        maze[fruitCell.row][fruitCell.col] = "F";
        fruitVisible = true;
      }
      fruitTimer = now;
    }
    if (fruitVisible && now - fruitTimer > fruitDuration) {
      if (fruitCell && maze[fruitCell.row][fruitCell.col] === "F") {
        maze[fruitCell.row][fruitCell.col] = ".";
      }
      fruitVisible = false;
      fruitTimer = now;
    }
  }

  function handleFruitEating() {
    if (fruitVisible && fruitCell &&
        pacman.row === fruitCell.row && pacman.col === fruitCell.col) {
      maze[fruitCell.row][fruitCell.col] = ".";
      score += 100;
      fruitVisible = false;
    }
  }

  // ===== Collisions & reset =====
  function handleGhostCollision() {
    for (const g of ghosts) {
      if (g.row === pacman.row && g.col === pacman.col) {
        if (g.mode === "flee") {
          score += 200;
          const s = ghostStarts[ghosts.indexOf(g)];
          g.row = s.row; g.col = s.col; g.prevRow = s.row; g.prevCol = s.col; g.mode = "scatter";
        } else {
          lives--;
          if (lives <= 0) { gameState = "gameover"; }
          else { resetPositions(false); }
        }
        break;
      }
    }
  }

  function resetPositions(levelUp) {
    pacman.row = pacmanStart.row; pacman.col = pacmanStart.col;
    pacman.prevRow = pacman.row; pacman.prevCol = pacman.col;
    pacman.direction = "left"; pacman.nextDirection = "left";

    ghosts.forEach((g,i) => {
      const s = ghostStarts[i];
      g.row = s.row; g.col = s.col; g.prevRow = s.row; g.prevCol = s.col;
      g.direction = ["left","up","right","down"][i%4];
      g.mode = levelUp ? "scatter" : "scatter";
    });
  }

  // ===== Rendering (with interpolation) =====
  function drawGame() {
    ctx.fillStyle = COLORS.background;
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    drawMaze();
    drawPacman();
    ghosts.forEach(drawGhost);
    drawHUD();
  }

  function drawMaze() {
    const cellW = canvas.width / COLS, cellH = canvas.height / ROWS;
    for (let r = 0; r < ROWS; r++) {
      for (let c = 0; c < COLS; c++) {
        const x = c * cellW, y = r * cellH, ch = maze[r][c];
        if (ch === "W") {
          ctx.fillStyle = COLORS.wall;
          ctx.fillRect(x, y, cellW, cellH);
        } else if (ch === "P") {
          ctx.fillStyle = COLORS.pellet;
          ctx.beginPath();
          ctx.arc(x + cellW/2, y + cellH/2, Math.min(cellW,cellH)/9, 0, Math.PI*2);
          ctx.fill();
        } else if (ch === "O") {
          ctx.fillStyle = COLORS.powerPellet;
          ctx.beginPath();
          ctx.arc(x + cellW/2, y + cellH/2, Math.min(cellW,cellH)/4, 0, Math.PI*2);
          ctx.fill();
        } else if (ch === "T") {
          ctx.strokeStyle = COLORS.pellet;
          ctx.lineWidth = 3;
          ctx.beginPath();
          ctx.moveTo(x, y + cellH/2);
          ctx.lineTo(x + cellW, y + cellH/2);
          ctx.stroke();
        } else if (ch === "F") {
          ctx.fillStyle = COLORS.fruit;
          ctx.beginPath();
          ctx.arc(x + cellW/2, y + cellH/2, Math.min(cellW,cellH)/3, 0, Math.PI*2);
          ctx.fill();
        }
      }
    }
  }

  function drawPacman() {
    const cellW = canvas.width / COLS, cellH = canvas.height / ROWS;
    const fx = pacman.prevCol + (pacman.col - pacman.prevCol) * renderAlpha;
    const fy = pacman.prevRow + (pacman.row - pacman.prevRow) * renderAlpha;
    const cx = fx * cellW + cellW/2;
    const cy = fy * cellH + cellH/2;
    const radius = Math.min(cellW, cellH) * 0.45;

    const angleMap = { right:[0.2,1.8], left:[1.2,2.8], up:[1.7,2.3], down:[0.7,1.3] };
    const [start,end] = angleMap[pacman.direction] || angleMap.right;

    ctx.save();
    ctx.translate(cx, cy);
    ctx.beginPath();
    ctx.arc(0, 0, radius, start*Math.PI, end*Math.PI, false);
    ctx.lineTo(0, 0);
    ctx.closePath();
    ctx.fillStyle = COLORS.pacman;
    ctx.fill();
    ctx.restore();
  }

  function drawGhost(g) {
    const cellW = canvas.width / COLS, cellH = canvas.height / ROWS;
    const fx = g.prevCol + (g.col - g.prevCol) * renderAlpha;
    const fy = g.prevRow + (g.row - g.prevRow) * renderAlpha;
    const cx = fx * cellW + cellW/2;
    const cy = fy * cellH + cellH/2;
    const radius = Math.min(cellW, cellH) * 0.45;

    ctx.save();
    ctx.translate(cx, cy);
    // body
    ctx.beginPath();
    ctx.arc(0, 0, radius, Math.PI, 2*Math.PI);
    ctx.lineTo(radius, radius*1.1);
    for (let i = 4; i > 0; i--) {
      ctx.arc((radius*0.8) - (i*(radius/2.5)), radius*1.1, radius/5, 0, Math.PI, true);
    }
    ctx.closePath();
    ctx.fillStyle = (g.mode === "flee") ? "#2ff" : g.color;
    ctx.fill();
    // eyes
    ctx.beginPath();
    ctx.arc(-radius/3, -radius/6, radius/5, 0, Math.PI*2);
    ctx.arc( radius/3, -radius/6, radius/5, 0, Math.PI*2);
    ctx.fillStyle = "#fff"; ctx.fill();
    // pupils
    let dx=0, dy=0;
    if (g.direction==="left") dx=-radius/7; else if (g.direction==="right") dx=radius/7;
    else if (g.direction==="up") dy=-radius/9; else if (g.direction==="down") dy=radius/9;
    ctx.beginPath();
    ctx.arc(-radius/3 + dx, -radius/6 + dy, radius/11, 0, Math.PI*2);
    ctx.arc( radius/3 + dx, -radius/6 + dy, radius/11, 0, Math.PI*2);
    ctx.fillStyle = "#00e6ff"; ctx.fill();
    ctx.restore();
  }

  function drawHUD() {
    ctx.font = "bold 24px monospace";
    ctx.fillStyle = COLORS.hudText;
    ctx.textAlign = "left";
    ctx.fillText("SCORE: " + score, 16, 36);
    ctx.fillText("LIVES: " + lives, canvas.width - 160, 36);
    if (gameState === "gameover") {
      ctx.textAlign = "center";
      ctx.font = "bold 48px monospace";
      ctx.fillStyle = "#ff2f2f";
      ctx.fillText("GAME OVER", canvas.width/2, canvas.height/2);
    }
  }
  </script>
</body>
</html>
